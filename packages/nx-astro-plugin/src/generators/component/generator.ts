import type { Tree } from '@nx/devkit';
import {
  readProjectConfiguration,
  formatFiles,
  joinPathFragments,
} from '@nx/devkit';
import { join } from 'node:path';
import { toPascal } from '../../utils/naming.js';
import { detectIntegrations } from '../../utils/astro.js';

interface Schema {
  project: string;
  name: string;
  directory?: string;
  type?: 'server' | 'client';
  framework?: 'react' | 'preact' | 'vue' | 'svelte' | 'angular';
}

type Framework = 'react' | 'preact' | 'vue' | 'svelte' | 'angular';

const FRAMEWORK_EXTENSIONS: Record<Framework, string> = {
  react: '.tsx',
  preact: '.tsx',
  vue: '.vue',
  svelte: '.svelte',
  angular: '.ts',
};

const CLIENT_FRAMEWORKS: Framework[] = [
  'react',
  'preact',
  'vue',
  'svelte',
  'angular',
];

export default async function generator(tree: Tree, options: Schema) {
  const proj = readProjectConfiguration(tree, options.project);
  const compName = toPascal(options.name);
  const baseDir = options.directory
    ? options.directory.replace(/\\/g, '/')
    : '';
  const targetDir = joinPathFragments(proj.root, 'src', 'components', baseDir);
  const componentType = options.type || 'server';

  // Detect installed integrations
  const integrations = detectIntegrations(proj.root);
  const installedFrameworks = CLIENT_FRAMEWORKS.filter((fw) =>
    integrations.includes(fw),
  );

  let framework: Framework | null = null;
  let extension: string;

  if (componentType === 'server') {
    extension = '.astro';
  } else {
    // Client component - determine framework
    if (options.framework) {
      framework = options.framework;
      if (!installedFrameworks.includes(framework)) {
        throw new Error(
          `Framework '${framework}' is not installed.\n` +
            `Installed frameworks: ${installedFrameworks.join(', ') || 'none'}\n` +
            `Install with: nx g @forastro/nx-astro-plugin:add-integration --project=${options.project} --names=${framework}`,
        );
      }
    } else if (installedFrameworks.length === 1) {
      // Auto-select single installed framework
      framework = installedFrameworks[0];
    } else if (installedFrameworks.length === 0) {
      throw new Error(
        'No client framework integrations found.\n' +
          `Install one with: nx g @forastro/nx-astro-plugin:add-integration --project=${options.project} --names=<framework>\n` +
          'Available frameworks: react, preact, vue, svelte, angular',
      );
    } else {
      throw new Error(
        `Multiple frameworks installed: ${installedFrameworks.join(', ')}\n` +
          'Please specify which framework to use with --framework=<name>',
      );
    }

    extension = FRAMEWORK_EXTENSIONS[framework];
  }

  const filePath = join(targetDir, `${compName}${extension}`);

  if (!tree.exists(filePath)) {
    const contents =
      componentType === 'server'
        ? generateServerComponent(compName)
        : generateClientComponent(compName, framework!);
    tree.write(filePath, contents);
  }

  await formatFiles(tree);
}

function generateServerComponent(name: string): string {
  return `---
// Generated by @forastro/nx-astro-plugin:component
export interface Props {
  title?: string;
}

const { title = '${name}' } = Astro.props;
---

<div class="${name.toLowerCase()}">
  <h2>{title}</h2>
  <!-- TODO: Add your component content here -->
</div>
`;
}

function generateClientComponent(name: string, framework: Framework): string {
  switch (framework) {
    case 'react':
      return generateReactComponent(name);
    case 'preact':
      return generatePreactComponent(name);
    case 'vue':
      return generateVueComponent(name);
    case 'svelte':
      return generateSvelteComponent(name);
    case 'angular':
      return generateAngularComponent(name);
  }
}

function generateReactComponent(name: string): string {
  return `import { useState, useEffect } from 'react';

export interface ${name}Props {
  title?: string;
}

export function ${name}({ title = '${name}' }: ${name}Props) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // TODO: Add side effects here
  }, []);

  return (
    <div className="${name.toLowerCase()}">
      <h2>{title}</h2>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
`;
}

function generatePreactComponent(name: string): string {
  return `import { signal, computed, effect } from '@preact/signals';

export interface ${name}Props {
  title?: string;
}

export function ${name}({ title = '${name}' }: ${name}Props) {
  const count = signal(0);
  const doubled = computed(() => count.value * 2);

  effect(() => {
    // TODO: Add effects here
    console.log('Count changed:', count.value);
  });

  return (
    <div class="${name.toLowerCase()}">
      <h2>{title}</h2>
      <p>Count: {count.value}</p>
      <p>Doubled: {doubled.value}</p>
      <button onClick={() => count.value++}>Increment</button>
    </div>
  );
}
`;
}

function generateVueComponent(name: string): string {
  return `<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';

interface Props {
  title?: string;
}

const props = withDefaults(defineProps<Props>(), {
  title: '${name}',
});

const count = ref(0);
const doubled = computed(() => count.value * 2);

onMounted(() => {
  // TODO: Add lifecycle logic here
});

function increment() {
  count.value++;
}
</script>

<template>
  <div class="${name.toLowerCase()}">
    <h2>{{ props.title }}</h2>
    <p>Count: {{ count }}</p>
    <p>Doubled: {{ doubled }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<style scoped>
.${name.toLowerCase()} {
  /* TODO: Add component styles here */
}
</style>
`;
}

function generateSvelteComponent(name: string): string {
  return `<script lang="ts">
import { onMount } from 'svelte';

interface Props {
  title?: string;
}

let { title = '${name}' }: Props = $props();

let count = $state(0);
let doubled = $derived(count * 2);

$effect(() => {
  // TODO: Add reactive effects here
  console.log('Count changed:', count);
});

onMount(() => {
  // TODO: Add mount logic here
});

function increment() {
  count++;
}
</script>

<div class="${name.toLowerCase()}">
  <h2>{title}</h2>
  <p>Count: {count}</p>
  <p>Doubled: {doubled}</p>
  <button on:click={increment}>Increment</button>
</div>

<style>
.${name.toLowerCase()} {
  /* TODO: Add component styles here */
}
</style>
`;
}

function generateAngularComponent(name: string): string {
  const selector = name
    .replace(/([A-Z])/g, '-$1')
    .toLowerCase()
    .replace(/^-/, '');

  return `import { Component, Input, signal, computed, effect } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-${selector}',
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class="${name.toLowerCase()}">
      <h2>{{ title() }}</h2>
      <p>Count: {{ count() }}</p>
      <p>Doubled: {{ doubled() }}</p>
      <button (click)="increment()">Increment</button>
    </div>
  \`,
  styles: [\`
    .${name.toLowerCase()} {
      /* TODO: Add component styles here */
    }
  \`]
})
export class ${name}Component {
  @Input() title = signal('${name}');
  
  count = signal(0);
  doubled = computed(() => this.count() * 2);

  constructor() {
    effect(() => {
      // TODO: Add effects here
      console.log('Count changed:', this.count());
    });
  }

  increment() {
    this.count.update(c => c + 1);
  }
}
`;
}
